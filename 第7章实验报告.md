# 第7章实验

[TOC]

## 实验名称

**简单栈溢出实验**

## 实验原理

栈被用于实现函数的调用和存储局部变量，当我们使用`strcpy`或`gets`**没有输入限制**的不安全的函数时，攻击者可以写入超过某个局部变量申请的字节数，使得数据向高地址区覆盖，修改返回地址，让程序按照攻击者的想法运行。

<img src="./img/7-1.png" alt="7-1" style="zoom:50%;" />

## 实验环境

```shell
# 系统环境
OS: Ubuntu 20.04 focal(on the Windows Subsystem for Linux)
Kernel: x86_64 Linux 5.15.90.1-microsoft-standard-WSL2
CPU: AMD Ryzen 7 5700U with Radeon Graphics @ 16x 1.797GHz
RAM: 1677MiB / 6858MiB
# gcc
gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0
# gdb
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
# objdump
GNU objdump (GNU Binutils for Ubuntu) 2.34
```

## 实验步骤

### 准备阶段

- 更新`gcc, gdb,checksec`

```shell
❯ apt update
❯ apt install gcc-multilib
❯ apt install gdb
❯ apt install checksec
```

- 关闭进程空间地址随机化

```shell
# 首先看一下地址随机化的效果，可以发现在ASLR开启时，动态库的加载地址不同
❯ ldd /bin/bash
        linux-vdso.so.1 (0x00007fffb3dc4000)
        libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007f6cef006000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f6cef000000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f6ceee0e000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f6cef171000)
❯ ldd /bin/bash
        linux-vdso.so.1 (0x00007ffc82124000)
        libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007f710a76b000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f710a765000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f710a573000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f710a8d6000)
# 关闭地址随机化
❯ sysctl -w kernel.randomize_va_space=0
kernel.randomize_va_space = 0
# 再次查看动态库的加载地址，可以看到两次加载的地址完全相同
❯ ldd /bin/bash
        linux-vdso.so.1 (0x00007ffff7fcd000)
        libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007ffff7e5e000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ffff7e58000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7c66000)
        /lib64/ld-linux-x86-64.so.2 (0x00007ffff7fcf000)
❯ ldd /bin/bash
        linux-vdso.so.1 (0x00007ffff7fcd000)
        libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007ffff7e5e000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ffff7e58000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7c66000)
        /lib64/ld-linux-x86-64.so.2 (0x00007ffff7fcf000)
```

- 编写测试程序如下：

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char input[] = "11112222333344445555666677778888";

void inject()
{
    printf("*****inject success*****\n");
}

void func_call()
{
    char param[16];
    strcpy(param, input);
}

int main(int argc, char** argv)
{
    func_call();
    printf("main exit...\n");
    return 0;
}

```

- 运行程序并检测保护机制

```shell
❯ gcc StackOverflow.c -o StackOverflow -Wall -m32 -g -fno-stack-protector -z execstack
# -Wall: 开启所有常规警告，便于检测代码问题
# -o: 指定输出文件名
# -g: 关闭所有优化体制
# -fno-stack-protector: 关闭Stack Canary保护
# -z execstack: 禁用 NX(No-eXecute protect)
# -m32: 将编译目标指定为32位

# 使用checksec检测目标文件的保护机制，确实没有Canary和NX保护
❯ checksec --file=StackOverflow
[*] '/root/StackOverflow'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      PIE enabled
    RWX:      Has RWX segments
    
# 查看运行结果
❯ ./StackOverflow
main exit...
```

### 实验阶段

经过一番准备，下面正式开始栈溢出攻击的实验。

#### 静态调试

- 打开IDA_Prox32，找到`inject`函数

<img src="./img/7-2.png" alt="7-2" style="zoom:80%;" />

- 找到`param`的位置

<img src="./img/7-3.png" alt="7-3" style="zoom:80%;" />
