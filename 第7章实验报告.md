# 第7章实验

[TOC]

## 实验名称

**简单栈溢出实验**

## 实验原理

栈被用于实现函数的调用和存储局部变量，当我们使用`strcpy`或`gets`**没有输入限制**的不安全的函数时，攻击者可以写入超过某个局部变量申请的字节数，使得数据向高地址区覆盖，修改返回地址，让程序按照攻击者的想法运行。

<img src="./img/7-1.png" alt="7-1" style="zoom:50%;" />

## 实验环境

```shell
# 系统环境
OS: Ubuntu 20.04 focal(on the Windows Subsystem for Linux)
Kernel: x86_64 Linux 5.15.90.1-microsoft-standard-WSL2
CPU: AMD Ryzen 7 5700U with Radeon Graphics @ 16x 1.797GHz
RAM: 1677MiB / 6858MiB
# gcc
gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0
# gdb
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2
# objdump
GNU objdump (GNU Binutils for Ubuntu) 2.34
```

## 实验步骤

### 准备阶段

- 更新`gcc, gdb,checksec`

```shell
❯ apt update
❯ apt install gcc-multilib
❯ apt install gdb
❯ apt install checksec
```

- 关闭进程空间地址随机化

```shell
# 首先看一下地址随机化的效果，可以发现在ASLR开启时，动态库的加载地址不同
❯ ldd /bin/bash
        linux-vdso.so.1 (0x00007fffb3dc4000)
        libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007f6cef006000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f6cef000000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f6ceee0e000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f6cef171000)
❯ ldd /bin/bash
        linux-vdso.so.1 (0x00007ffc82124000)
        libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007f710a76b000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f710a765000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f710a573000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f710a8d6000)
# 关闭地址随机化
❯ sysctl -w kernel.randomize_va_space=0
kernel.randomize_va_space = 0
# 再次查看动态库的加载地址，可以看到两次加载的地址完全相同
❯ ldd /bin/bash
        linux-vdso.so.1 (0x00007ffff7fcd000)
        libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007ffff7e5e000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ffff7e58000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7c66000)
        /lib64/ld-linux-x86-64.so.2 (0x00007ffff7fcf000)
❯ ldd /bin/bash
        linux-vdso.so.1 (0x00007ffff7fcd000)
        libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007ffff7e5e000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ffff7e58000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7c66000)
        /lib64/ld-linux-x86-64.so.2 (0x00007ffff7fcf000)
```

- 编写测试程序如下：

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char input[] = "11112222333344445555666677778888";

void inject()
{
    printf("*****inject success*****\n");
}

void func_call()
{
    char param[16];
    strcpy(param, input);
}

int main(int argc, char** argv)
{
    func_call();
    printf("main exit...\n");
    return 0;
}

```

- 运行程序并检测保护机制

```shell
❯ gcc StackOverflow.c -o StackOverflow -Wall -m32 -g -fno-stack-protector -z execstack
# -Wall: 开启所有常规警告，便于检测代码问题
# -o: 指定输出文件名
# -g: 关闭所有优化体制
# -fno-stack-protector: 关闭Stack Canary保护
# -z execstack: 禁用 NX(No-eXecute protect)
# -m32: 将编译目标指定为32位

# 使用checksec检测目标文件的保护机制，确实没有Canary和NX保护
❯ checksec --file=StackOverflow
[*] '/root/StackOverflow'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      PIE enabled
    RWX:      Has RWX segments
    
# 查看运行结果
❯ ./StackOverflow
main exit...
```

### 实验阶段

经过一番准备，下面正式开始栈溢出攻击的实验。

#### 动态调试

使用`gdb`工具（已安装`gef`插件），具体过程如下

```shell
❯ gdb -q StackOverflow
gef➤  start
# 在func_call设置断点
gef➤  b func_call
Breakpoint 1 at 0x5655621c: file StackOverflow.c, line 13.
# 运行程序
gef➤  run
# 查看栈帧
gef➤  info frame
Stack level 0, frame at 0xffffcf00:
 eip = 0x5655621c in func_call (StackOverflow.c:13); saved eip = 0x56556272
 called by frame at 0xffffcf20
 source language c.
 Arglist at 0xffffcef8, args:
 Locals at 0xffffcef8, Previous frame's sp is 0xffffcf00
 Saved registers:
  eip at 0xffffcefc
gef➤  s
// param=0xffffcee0  →  [...]  →  0x00000000
```

我们可以看到当前栈帧的地址为`0xffffcf00`

```shell
# 查看栈的内容
gef➤  x/32gx $esp  # 其中x表示eXamine（查看），32表示要查看的内存字节数，g表示以16进制格式显示，x表示显示的数据格式为16进制整数
0xffffcefc:     0xffffcf2056556272      0x0000000000000000
0xffffcf0c:     0xf7fb5000f7de4ed5      0x00000000f7fb5000
0xffffcf1c:     0x00000001f7de4ed5      0xffffcfbcffffcfb4
0xffffcf2c:     0xf7fb5000ffffcf44      0xffffcf98f7ffd000
0xffffcf3c:     0xf7ffd99000000000      0xf7fb500000000000
0xffffcf4c:     0x00000000f7fb5000      0x8b0e7f91c80d1981
0xffffcf5c:     0x0000000000000000      0x0000000000000000
0xffffcf6c:     0x0000000000000000      0xf7fe215d00000000
0xffffcf7c:     0x0000000156558fd4      0x00000000565560b0
0xffffcf8c:     0x5655624f565560e5      0xffffcfb400000001
0xffffcf9c:     0x56556310565562a0      0xffffcfacf7fe22b0
0xffffcfac:     0x000000010000001c      0x00000000ffffd126
0xffffcfbc:     0xffffd14affffd13a      0xffffd72bffffd157
0xffffcfcc:     0xffffd765ffffd73f      0xffffd78affffd770
0xffffcfdc:     0xffffd7caffffd7b2      0xffffd81bffffd7eb
0xffffcfec:     0xffffd872ffffd850      0xffffd88bffffd880
```

这样，我们得到了`func_call`的返回地址`0xffffd872ffffd850`，现在我们想要将这个地址替换成`inject`函数的地址。

这需要先计算地址的偏移量，

#### 静态调试

- 打开IDA_Prox32，找到`inject`函数

<img src="./img/7-2.png" alt="7-2" style="zoom:80%;" />

- 找到`param`的位置

<img src="./img/7-3.png" alt="7-3" style="zoom:80%;" />



